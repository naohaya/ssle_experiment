/**
 * This program outputs a random value for electing a leader 
 * and a punctured secret value based on the secret value obtained as an input.
 * The punctured secret value is generated by convolutional encoding.
*/

#include <iostream>
#include <cstdlib>
#include <cstring>
#include <cassert>
#include <sstream>
#include <string>
#include <vector>
#include <ctime>
#include "prvhash_core.h"
#include "cmdline.h"
#include "viterbi.h"

using namespace std;

class PPRF {
public:
    PPRF(){}
    uint64_t hexToDecimal(string); // converting from hex string to decimal value (uint64_t)
    vector<char> hexToBinary(string); // converting from hex string to Binary array (vector<char>)
    string prf(uint64_t *, uint64_t *, uint64_t *); // pseudo-random function
    string puncturing(string); // puncturing the bit string by convolutional coding
    string depuncturing(string); // depuncturing the bit string by viterbi decorder
    string decimalToBinary(uint64_t); // converting from decimal value (uint64_t) to binary string
    string binaryToHex(string); // converting from binary string to hex string
    vector<string> splitBinaryVector(string&, int); 
    string bitFlip(const string&); // random bit flips
    string align(string);
private:
    int keySize = 0;
    bool debug = false;
};



/* pseudo-random function */
string PPRF::prf(uint64_t *seed, uint64_t *lcg, uint64_t *hash){        
    uint64_t ret = 0;
    uint64_t i;
    // generating a random value by prf
    for ( i = 0; i < ( 1ULL << 28); i++) {
        ret = prvhash_core64(seed, lcg, hash);
    }    

    return align(decimalToBinary(ret));

}

/* puncturing a random value bit string using convolutional erasure code + bit flips */
string PPRF::puncturing(string rvalue) {
    vector<string> splvec;
    vector<int> polynomials;
    int constraint = 3;
    ostringstream oss;
    string rval_str = rvalue;
    string enc;
    string punc;
    string result;

    polynomials.push_back(6);
    polynomials.push_back(5);
    ViterbiCodec codec(constraint, polynomials);

//    rval_str = decimalToBinary(rvalue); // converted from unit64_t to binary vector
    keySize = rval_str.size();

//    std::cout << "size: " << keySize << " key: " << rval_str << std::endl; // for debug

    splvec = splitBinaryVector(rval_str, 7);

    
    for (auto itr = splvec.begin(); itr != splvec.end(); ++itr) {
        enc = codec.Encode(*itr);
        punc = bitFlip(enc); // encoding and bit flipping
        result += punc;
        if(debug){
            cout << "vec: " << *itr << endl; // for debug
            cout << " enc: " << enc;  // for debug
            //cout << " hex: " << binaryToHex(codec.Encode(*itr));
            cout << " punc: " << punc << endl; // for debug
        }
    }

    //std::cout << "punctured: " << codec.Encode(rval_str) << std::endl;

    return result;

}

/* depuncturing a bit string by viterbi decoder */
string PPRF::depuncturing(string bits) {
    vector<string> splvec;
    vector<int> polynomials;
    int constraint = 3;
    ostringstream oss;
    string rval_str = bits;
    string dec;
    string punc;
    string result;

    polynomials.push_back(6);
    polynomials.push_back(5);
    ViterbiCodec codec(constraint, polynomials);

    keySize = rval_str.size();

    splvec = splitBinaryVector(rval_str, 18);

    for (auto itr = splvec.begin(); itr != splvec.end(); ++itr) {
        dec = codec.Decode(*itr);
        result += dec;
        if(debug){
            cout << "vec: " << *itr << endl; // for debug
            cout << " dec: " << dec;  // for debug
        }
    } 

    return result;

}

/* random bit flips */
string PPRF::bitFlip(const string& inbits){
    string bits = inbits;
    srand( time(NULL) );
    int insize = bits.size();
    int pos, offset;
    pos = rand() % insize;
    offset = (rand() % insize/3) * 2;

    if (bits[pos] == '0'){
        bits[pos] = '1';
    } else {
        bits[pos] = '0';
    }

    if (bits[(pos + offset) % insize] == '0') {
        bits[(pos + offset) % insize] = '1';
    } else {
        bits[(pos + offset) % insize] = '0';
    }

    return bits;

}

/* converting from string to unit64_t */
uint64_t PPRF::hexToDecimal(std::string sarg) {
    unsigned int value;
    uint64_t ret;
    istringstream iss(sarg);

    iss >> hex >> value;

/*    value << std::hex << iss; */

    cout << sarg << endl;

    ret = static_cast<uint64_t>(value); 

    return ret;
}

/* converting from hex string to binary vector */
std::vector<char> PPRF::hexToBinary (std::string inHex){
    char tmp[256], out[256];
    long b = strtol(tmp, NULL, 16);
    int i = 0;
    std::vector<char> v;

    while(b) {
        out[i++] = b%2 + '0';
        b /= 2;
    }

    while(i--) {
        v.push_back(out[i]);
    }

    return v;
}

/* converting from binary vector to hex string */
std::string PPRF::binaryToHex (std::string inBin) {
    uint64_t num;
    stringstream ss;
    istringstream iss = istringstream(inBin);

    iss >> num;
    
    ss << std::hex << num;

    return ss.str();

}

/* split vector in to a small vector of a certain length */
vector<string> PPRF::splitBinaryVector (string& vec, int num){

    vector<string> result;
 
    for (size_t i = 0; i < vec.size(); i += num) {
        result.push_back(vec.substr(i, num));
    }
 
    //padding with 0
    if (result[result.size() - 1].size() < num) {
        for(int remaining = num - result[result.size() - 1].size(); remaining < 0; remaining--) {
            result[result.size() - 1] += '0';
        }

    }

    return result;

}

string PPRF::decimalToBinary(uint64_t n) {
 
    string result;
    while (n != 0){
        result += n % 2 == 0 ? '0' : '1' ;
        n /= 2;
    }
    reverse(result.begin(), result.end());
    return result;
}

string PPRF::align(const string bits){
    string rval_str = bits;
    string result;
    int keySize = rval_str.size();
    int remain = keySize % 7; // currently key size should be a multiples of 7
    result = rval_str.erase(keySize - remain);

    if(debug){
        std::cout << "input size: " << keySize << " key: " << rval_str << std::endl; // for debug
        std::cout << "output size: "<< result.size() << "key: " << result << std::endl; // for debug
    }

    return result;

}

/* Test code for using the class PPRF */
/*
int main(int argc, char* argv[]){
//    const uint64_t defaultSeed = 0x93064E905C127FE5;
    const uint64_t defaultSeed = 0xF3D6FE905C127FE5;
    const uint64_t defaultHash = 0xA4BDE5C4A05E6256;
    const uint64_t defaultlcg = 0;
    int keySize = 0;

    uint64_t seed = defaultSeed; // secret 
    uint64_t lcg = defaultlcg;
    uint64_t hash = defaultHash; // key 
    string v = "";
    string result;
    string depunct;

    PPRF pr = PPRF();
    
    //std::string in_seed;
    //std::string in_hash;

    // for analyzing command line arguments 
    cmdline::parser cla;
    cla.add<string>("secret", 's', "secret value", false);
    cla.add<string>("key", 'k', "key value", false);
    cla.add("help", 0, "print usage");

    if(!cla.parse(argc, argv) || cla.exist("help")) {
        std::cout << cla.error_full() << cla.usage();
        return 0;
    }

    if (cla.exist("secret")) {
        //in_seed = argv[2]; //p.get<std::string>("secret"); 
        seed = pr.hexToDecimal(argv[2]);
    }

    if(cla.exist("key")) {
        // hash = hexToDecimal(p.get<std::string>("key")); 
        //in_hash = argv[4];
        hash = pr.hexToDecimal(argv[4]);
    }



    cout << "secret: " << seed << endl;

    v = pr.prf(&seed, &lcg, &hash);

    cout << "key (decimal): " << v << endl; 

    result = pr.puncturing(v);

    cout << "punctured key: " << result << endl;

    depunct = pr.depuncturing(result);

    cout << "depunctured key: " << depunct << endl;

}
*/

